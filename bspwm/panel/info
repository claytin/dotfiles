#!/usr/bin/env perl

use 5.020;
use warnings;

## TODO
## add wifi
## add battery

## Colors
my $NORMAL_FG = "#e3e5e3";
my $NORMAL_BG = "#151515";

my $OCCUPIED_FG = "#ff839496";

## Font Slots
## The assigned fonts can be found in ./panel_cfg

## Icons/Glyphs
my $DATE_ICON  = "\x{e266}";
my $CLOCK_ICON = "\x{e015}";
my $CPU_ICON   = "\x{e026}";
my $TEMP_ICON  = "\x{e01b}";
my $MEM_ICON   = "\x{e021}";
my $AC_ICON    = "\x{e041}";
my $BATL_ICON  = "\x{e1fd}";
my $BATM_ICON  = "\x{e1fe}";
my $BATF_ICON  = "\x{e1ff}";
my $BATC_ICON  = "\x{e201}";

# should format the string
sub frmt {
     (my $color, my $str, my $font) = @_;

     if ($font) {
          return "%{F$color}%{T$font}$str%{T-}%{F-}";
     }

     return "%{F$color}$str%{F-}";
}

## Widgets (section name borowed from awesome wm)
# returns a list containing only the "active" desktops
sub desktopwgt {
     chomp(my $status = `bspc control --get-status`);

     # mon (monitor); unused
     # dskt (desktops); complete list of desktops and their status
     my ($mon, @dskt) = split /:/, $status;

     my $dstr = ""; # dstr (desktop string)
     foreach my $e (@dskt) { # e (entry)
          given ($e) {
               when (/^o/) { # occupied desktop
                    $dstr .= " " . &frmt($OCCUPIED_FG, (substr $e, 1), 2);
               }

               when (/^[OF]/) { # focused desktop (occupied or not)
                    $dstr .= " " . &frmt($NORMAL_FG, (substr $e, 1), 2);
               }

               default { continue } # free desktops (not focused)
          }
     }

     return $dstr;
}

sub datewgt {
     # this format is needed due to, what seems tobe, encoding problems
     chomp(my $ds = `date +"%a"`);
     $ds = "SÃ¡b" if $ds =~ /S*b/;
     chomp($ds .= `date +", %d %b"`);

     chomp(my $hour = `date +"%H:%M"`);

     return sprintf("%s%s %s%s", &frmt($OCCUPIED_FG, $DATE_ICON, 2)
                               , &frmt($NORMAL_FG, $ds, 1)
                               , &frmt($OCCUPIED_FG, $CLOCK_ICON, 2)
                               , &frmt($NORMAL_FG, $hour, 1));
}

sub netwgt { }

sub energywgt {
     chomp(my $acstat = `cat /sys/class/power_supply/A*/online`);
     chomp(my $batstat = `cat /sys/class/power_supply/B*/status`);

     chomp(my $cfull = `cat /sys/class/power_supply/B*/charge_full`);
     chomp(my $cnow = `cat /sys/class/power_supply/B*/charge_now`);

     my $batprcnt = (100 * $cnow) / $cfull;

     if ($acstat eq "1") { # ac connected
          if ($batstat eq "Charging") {
               return sprintf("%s%s ", &frmt($OCCUPIED_FG, $BATC_ICON, 2)
                                     , &frmt($NORMAL_FG, "$batprcnt%", 1));
          }

          return &frmt($OCCUPIED_FG, $AC_ICON, 2);
     } else {
          if ($batprcnt <= 33) {
               return sprintf("%s%s ", &frmt($OCCUPIED_FG, $BATL_ICON, 2)
                                     , &frmt($NORMAL_FG, "$batprcnt%", 1));
          } elsif ($batprcnt <= 66) {
               return sprintf("%s%s ", &frmt($OCCUPIED_FG, $BATM_ICON, 2)
                                     , &frmt($NORMAL_FG, "$batprcnt%", 1));
          } else {
               return sprintf("%s%s ", &frmt($OCCUPIED_FG, $BATF_ICON, 2)
                                     , &frmt($NORMAL_FG, "$batprcnt%", 1));
          }
     }
}

sub cpuloadwgt {
     # adapted from meeting-at-the-bar
     chomp(my $lines = `ps -eo pcpu,args |\
                        grep -vE "^\\s*(0.0|%CPU)" |\
                        awk -e '{print \$1}'`);

     my $sum = 0;
     foreach my $prtn (split /\n/, $lines) {
          $sum += $prtn;
     }

     return sprintf("%s%s", &frmt($OCCUPIED_FG, $CPU_ICON, 2),
                          , &frmt($NORMAL_FG, "$sum% ", 1));
}

sub thrmwgt {
     chomp(my $acpit = `acpi -t | awk '{ printf("%d\\n", \$4)}'`);
     my @thrm = split /\n/, $acpit;

     my $ft = 0;
     for (my $i = 0; $i < @thrm; $i++) {
          $ft = $thrm[$i] if ($thrm[$i] > $ft);
     }

     return sprintf("%s%s", &frmt($OCCUPIED_FG, $TEMP_ICON, 2)
                          , &frmt($NORMAL_FG, "$ft\x{00b0}C ", 1));
}

sub umemwgt {
     chomp(my $umem = `free -m | awk '/Mem/ { print \$3 }'`); # used memory

     return sprintf("%s%s", &frmt($OCCUPIED_FG, $MEM_ICON, 2) ,"${umem}MB ");
}

while (1) {
     say "%{l}", &desktopwgt,
         "%{c}", &datewgt,
         "%{r}", &energywgt, &cpuloadwgt, &thrmwgt, &umemwgt;

     sleep 1;
}
